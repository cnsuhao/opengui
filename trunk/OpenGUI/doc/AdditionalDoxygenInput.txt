/*!
	\mainpage OpenGUI Documentation
	
	\image html logo.jpg
	
	%OpenGUI is an easy to use and easy to extend GUI framework for use in 3D applications.
	The core aim of %OpenGUI is to provide developers of 3D applications a drop in
	system for creating simple GUIs without hassle, while still providing an easy method
	of extendability for creating complex GUIs with custom widgets.
	<BR><BR>
	See the list of \subpage Features "features" for details.
	<BR><BR>
	
	
	
	\section UserDocs User Documentation
	The user documentation is divided into several sections and is intended to provide
	explanations and examples of library usage, as well provide a few advanced topics
	such as how to extend the GUI through custom widgets.
	
	- \subpage IntegratingOpenGUI "Integrating OpenGUI"
	
	- \subpage XMLDOC "XML Configuration Files"
	
	- \subpage CreatingWidgets "Creating Widgets"
	
	- \subpage MessageSystem  "The Message System"
	
	- \subpage BaseWidgets "Base Widget Documentation"
	
	- \subpage CustomWidgets "Extending via Custom Widgets"
	
	\n\n\n
	<hr>	
	\note
	%OpenGUI is distributed using the  BSD license so that both amateur and
	professional developers can benefit from its use. The exact copy of
	this license can be found in the file LICENSE.TXT that is distributed with the
	source code, or by clicking \link License here.\endlink
*/
/*!
	\page License
	%OpenGUI is freely usable/distributable under the BSD license, the contents of which follow:
	<HR>
	\verbinclude LICENSE.TXT
	<BR><HR><BR>
	%OpenGUI also utilizes a few external libraries. The names, websites and license types of these
	external libraries are listed below.
	<HR>
	Name: Corona (version 1.0.2)\n
	Website: http://corona.sourceforge.net/ \n
	License: <a href="http://opensource.org/licenses/zlib-license.html">zlib license</a> \n
	<HR>
	Name: TinyXML (version 2.4.3)\n
	Website: http://www.grinninglizard.com/tinyxml/index.html \n
	License: <a href="http://opensource.org/licenses/zlib-license.html">zlib license</a> \n
	<HR>
	Name: Freetype (version 2.1.10)\n
	Website: http://www.freetype.org/ \n
	License: <a href="http://freetype.sourceforge.net/FTL.TXT">The FreeType License</a> \n
	Credit as requested:\n
\verbatim
Portions of this software are copyright © 2006
The FreeType Project (www.freetype.org). All rights reserved.
\endverbatim
	
*/
/*!
	\page Features
		
	- Easily integrated with any input system: All input is injected into the system by the application using simple function calls.
	- Input injection logging with log playback feature.
	- Cross API: Is easily used in native DirectX or OpenGL, as well as the OGRE rendering engine.
	- Avoids custom containers when possible, using STL where available.
	- Easily extendable widget set by class inheritance.
	- Powerful message system with fully catchable and interruptable parent/child event propagation.
	- Auto scaling, pixel aligned fonts, rendered via FreeType 2.
	- Supports native loading of mutiple imagery formats via Corona (http://corona.sourceforge.net)
	- Full alpha support for image types that support alpha channels. (Single channel imagery is interpretted as alpha only.)
	- Free form render operations allow Widget imagery to be rotated and scaled in any way imaginable.
	- Provides input logging and playback functionality for automated application testing.
	- Plugin system so custom widgets can be used in any application without recompiling.
	
	\note
	%OpenGUI is still very much a work in progress. This list of features
	is accurate to the best of my knowledge. If %OpenGUI is missing a
	feature that you feel it should have, please feel free to submit a patch.
*/


/*!
	\page MessageSystem The Message System

	Messages are used with %OpenGUI for nearly all communication. The base functionality
	necessary to support the message system is implemented as private functions within
	the Element class (which is a base class for the Widget class). So all custom
	widgets will implicitly have the necessary message passing functionality built in,
	and will not need to implement any additional functionality to support the message
	system. As messages are passed from widget to widget, each widget is given a chance
	to look at the message, and determine if it can handle it best. During this message
	peeking opportunity, a widget can decide if the message no longer needs to continue
	its widget-hopping journey, and propagation will be stopped.

	\section MessageTypes Message Types

	Messages come in 2 types, Events and Alerts. This section will cover the differences
	between them.

	\subsection MessageTypesEvents Events

	Events are generated by the system, and are sent down the Widget hierarchy, starting
	at the GUISheet, working directly toward a destination widget. This is referenced as
	a directed event. Alternatively, events can also be sent as global events. A global
	event starts at the GUISheet just as a directed event, but instead of following a
	direct line toward its destination it branches at every fork in the hierarchy. The
	following image should help clear up any uncertainties about the 2 different event
	propagation types.

	\image html EventPropagation.jpg "Event Propagation Example"

	The primary use of events is to notify Widgets of important information. Things like
	mouse movement and button clicks, keystrokes, and gui sheet activation are all types
	of information that are sent from the system to a widget using events.

	\see \subpage EventTypes "The complete list of Event Types"

	\subsection MessageTypesAlerts Alerts

	Alerts are much like events, with very simple differences. First, they always
	originate from a Widget, and propagate back up the hierarchy toward the GUISheet.
	Second, since they never have any opportunities to fork (as they travel in the wrong
	direction of the tree), they do not have a global propagation method.

	\image html AlertPropagation.jpg "Alert Propagation Example"

	The primary use of alerts is to provide widgets a method of providing feedback to
	the application based on received events. If a button widget is "pressed", then that
	widget should send an alert back up the hierarchy to inform anyone who is listening.
	Since alerts are so tightly bound to the widget that is issuing them, they can only
	be evaluated by referencing the documentation of the specific widget.
	
	\see \ref BaseWidgets "The complete list of base widgets"
*/



/*!
	\page CustomWidgets
	This page explains how to create custom widgets to extend the gui.
	\todo finish me
	\section RecievingEvents Receiving Events
	\section IssuingAlerts Issuing Alerts
*/




/*! \page DefaultImageset
	There is a default image that is used whenever an Imageset is unloaded when there are
	still Imagery objects that refer to it used within Widgets. This image is built directly
	into the library source, and is always immediately loaded as a texture when the System
	object is created.
	
	Just so you know what to look for, here it is:
	 
	 
	\image html UnknownImage.bmp
	
	\note
	This functionality may be removed in the future, as it is already disabled in the SVN HEAD,
	and seems like a functionality that may be better enforced at the renderer level, rather than
	within %OpenGUI itself.
*/

/*! \page IntegratingOpenGUI
	This will cover how to add OpenGUI to your application
*/

/*!
	\page CreatingWidgets Creating Widgets
	\todo this page needs to be finished
	
	\section newWidget Direct Creation via "new"
	SomeWidget* w = new SomeWidget;
	
	\section createWidget Widgets by name
	Widgets can be created via System::createWidget
	
	\section WidgetTemplate Widget Templates
	Templates allow you to create widgets with preconfigured properties.
*/

/*! \page CoordinateSpaces Coordinate Spaces
	Working with coordinates within GUIs can often become more difficult than you would
	initially expect. The reason for this comes from the constant changes of coordinate space.
	As you build a GUI hierarchy, you are nesting widgets within other widgets. The top level
	widget (the first added to the hierarchy) is positioned and sized using the coordinate
	system defined by the GUISheet. However, a child of that top level widget may or may not
	use that same coordinate system. It is up to the containing widget to define the coordinate
	space in which its children reside.
	
*/

/*! \page WhyCallbacks Why Callbacks?
	As you work with %OpenGUI, you will undoubtedly notice that C style callbacks are used
	in more than one place. In fact, it is quite hard to use %OpenGUI and never run into a
	callback. So you might end up asking, "What gives? Why are you using C style function
	callbacks when your competition allows the direct callback of object member functions?"
	
	Revision 5 in the repository actually contains a working implementation of a system that
	provides such an interface, and this system was originally used quite gratuitously throughout
	the code base. During the usage of this system, a distinct downfall was noticed.
	
	It had the major drawback that it didn't work at all when you tried to use it
	on a class with multiple inheritance. It worked absolutely fine on all other classes,
	including those that had single inheritance. Even virtual functions worked as advertised.
	But, as soon as a class had more than 1 immediate base class, it died horribly, refusing
	to compile.
	
	Because we cannot impose such a limitation on the class inheritance of the user base,
	and the need for a stable release of the library trumps the need of nifty polymorphism
	compatible object member function callbacks, standard C callbacks are used wherever
	such an interface is necessary. If the C++ committee ever decides upon a safe standard for
	member function callbacks, they will be implemented. Until then, patches on this subject
	are welcomed, but should only enhance the existing structure, not replace it.
*/
