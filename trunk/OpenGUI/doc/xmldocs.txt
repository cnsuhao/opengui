/*!
<!-- This document is best edited with WORD WRAPPING! -->
\page XMLDOC XML Documentation

%OpenGUI provides the use of XML based configuration files to allow users to set up various aspects of their GUI without having to hard code everything. These XML files can be loaded via OpenGUI::XMLParser::LoadFromFile(). The individual tag names within these documents are always parsed as case insensitive. That may or may not be standard XML practice, but for simplicity %OpenGUI ignores the case of tag names and attribute names. <i>The contents of attributes may or may not be case sensitive depending on their context.</i>
\note Attributes can be in any order, so feel free to rearrange them as you see fit.

\note Standard XML comments are supported.

\see There are also functions that will parse XML config files that only recognize certain tags, and silently ignore all other tags they aren't specifically interested in. These are: 
 - OpenGUI::FontManager::LoadFontsFromXML()
 - OpenGUI::ImageryManager::LoadImagesetsFromXML()
 - OpenGUI::WidgetTemplateManager::LoadTemplatesFromXML()
 - OpenGUI::LayoutLoader::LoadLayoutFromXML()
 - OpenGUI::PluginManager::LoadPluginsFromXML()

\warning The XML parsers perform actions on the data <i>as they read it</i>. Meaning that you cannot create Widgets based on Templates until the Template tags have been parsed, or perform any other out-of-order operation. The XML logic is very basic by design, and it all nearly directly translates into API calls, which are noted in the tag's documentation.

<hr>
\section quicktags Quick Tag List:
 - \ref include
 - \ref font
 - \ref plugin
 - \ref imageset 
 - \ref imagery 
 - \ref guisheet 
 - \ref widget 
 - \ref property
 - \ref template
 
<hr>



\section example Example Config File
The following is an example xml file. Its contents will be referenced in the following sections. It is listed here in its entirety so that you can get an idea of what a common config file looks like.
\verbatim
<?xml version="1.0" ?>
<Include file="metal.xml" />
<Plugin file="TachometerWidget" />
<Font name="pecot" file="pecot.ttf" xres=800 yres=600 autoscale=true />
<Imageset sourceimage="tachometer.png">
	<Imagery Name="TachBG" XPos="2" YPos="2" Width="321" Height="321" />
	<Imagery Name="TachNeedle" XPos="42" YPos="348" Width="131" Height="7" />
</Imageset>
<Template name="tachometer" group="OpenGUIExt" type="Tachometer">
	<Property name="BGImagery" value="TachBG" />
	<Property name="NeedleImagery">TachNeedle</Property>
	
	<Property name="position" value="(0.59875 x0.465)" />
	<Property name="size" value="(0.40125x0.535)" />
	
	<Property name="needlepivot" value="(0.50x0.50)" />
	<Property name="needleanchor" value="(0.10x0.50)" />
	
	<Property name="NeedleMinValue" value="0" />
	<Property name="NeedleMaxValue" value="900" />
	<Property name="NeedleMinAngle" value="-135" />
	<Property name="NeedleMaxAngle" value="90" />
	
	<Property name="needlevalue" value="0" />
</Template>
<GUISheet name="root">
	<Widget name="myTach" type="tachometer" />
	<Widget name="test" group="OpenGUI" type="TextLabel">
		<Property name="position" value="(0.0 x0.0)" />
		<Property name="size" value="(1x1)" />
		<Property name="font" value="pecot" />
		<Property name="fontsize" value="50" />
		<Property name="text" value="OpenGUI Demo 1" />
	</Widget>
	<!--<Widget name="test" group="OpenGUI" type="StaticImage">
		<Property name="position" value="(0.0 x0.0)" />
		<Property name="size" value="(1x1)" />
	</Widget>-->
</GUISheet>
\endverbatim


\note The \<?xml version="1.0" ?\> line is not required by TinyXML, but you may want to add it anyways.




<hr>
\section include <Include>
Performs what is effectively an inline include of the given file. <i>The included file will be parsed for XML based configuration content.</i>

Each file can only be included once per execution of OpenGUI::XMLParser::LoadFromFile(). Subsequent requests for an include file are logged as warnings, but otherwise ignored. <i>(The multiple include testing is performed using a simple case-insensitive string comparison. Minor path tricks will fool it, but are generally discouraged.)</i>

Example:
\verbatim
<Include file="metal.xml" />
\endverbatim

\par Attributes
 - \c File \b (required)
   - \em Type: string
   - \em Description: The path and filename where the config file to include can be located. This is passed verbatim to the ResourceManager, so anything that it can decipher can be used.

\note This is a top level tag only. For instance, you cannot have an \<Include\> inside of an \<Imageset\>. In that situation, the \<Include\> tag is ignored.


<hr>
\section font <Font>
To load a font, you can either call OpenGUI::FontManager::CreateFont(), or you can use a config file and the \c \<FONT\> tag.

Example:
\verbatim
<Font name="pecot" file="pecot.ttf" xres=800 yres=600 autoscale=true />
\endverbatim

\par Attributes
 - \c Name \b (required)
   - \em Type: string
   - \em Description: Name by which the font will be referenced within %OpenGUI. This does not have to be the same as the filename.
 - \c File \b (required)
   - \em Type: string
   - \em Description: The path and filename where the actual font can be located. This is passed verbatim to the ResourceManager, so anything that it can decipher can be used.
 - \c Autoscale
   - \em Type: boolean \c true / \c false
   - \em Default: \c false
   - \em Description: Signifies if this font is to be autoscaled according to the current screen resolution vs its native resolution.
 - \c Xres
   - \em Type: unsigned int
   - \em Default: \c 800
   - \em Description: The native screen resolution along the X axis for this font. Ignored unless \c autoscale is \c true.
 - \c Yres
   - \em Type: unsigned int
   - \em Default: \c 600
   - \em Description: The native screen resolution along the Y axis for this font. Ignored unless \c autoscale is \c true.






<hr>
\section plugin  <Plugin>
Loads a plugin by passing the given \c file to OpenGUI::PluginManager::loadPlugin().

Example:
\verbatim
<Plugin file="TachometerWidget" />
\endverbatim

\par Attributes
 - \c File \b (required)
   - \em Type: string
   - \em Description: The filename to be passed to OpenGUI::PluginManager::loadPlugin().

\see OpenGUI::PluginManager::loadPlugin() has the potential to perform filename mangling. See its documentation for more information.







<hr>
\section imageset <Imageset>
Loads the given \c sourceimage as an imageset via OpenGUI::ImageryManager::createImageset().

Example:
\verbatim
<Imageset sourceimage="tachometer.png">
	<!-- some <Imagery> tags in here -->
</Imageset>
\endverbatim

\par Attributes
 - \c Sourceimage \b (required)
   - \em Type: string
   - \em Description: The path and filename where the actual image file to load can be located. This is passed verbatim to the ResourceManager, so anything that it can decipher can be used.

\note Due to the way the ImageryManager treats duplicate requests to createImageset(), duplicate entries of this tag have no ill effect, and the \<Imagery\> enclosed  within any duplicates will be added to the originally established Imageset.









<hr>
\section imagery <Imagery>
Adds an Imagery to the enclosing Imageset via OpenGUI::Imageset::createImagery().
This tag \b must be enclosed by an \<Imageset\> tag or it is ignored!

Example:
\verbatim
<Imageset sourceimage="somefile">
	<Imagery Name="TachBG" XPos="2" YPos="2" Width="321" Height="321" />
</Imageset>
\endverbatim

\par Attributes
 - \c Name \b (required)
   - \em Type: string
   - \em Description: The name to give this Imagery object.
 - \c XPos \b (required)
   - \em Type: int
   - \em Description: The X value of the upper left corner of this Imagery within the Imageset in pixels.
 - \c YPos \b (required)
   - \em Type: int
   - \em Description: The Y value of the upper left corner of this Imagery within the Imageset in pixels.
 - \c Width \b (required)
   - \em Type: int
   - \em Description: The width of this Imagery within the Imageset in pixels.
 - \c Height \b (required)
   - \em Type: int
   - \em Description: The height of this Imagery within the Imageset in pixels.

\see Multiple \<Imagery\> tags with the same \c Name will redefine the Imagery as defined in OpenGUI::Imageset::createImagery().










<hr>
\section guisheet <GUISheet>
This tag allows you to create or alter a GUISheet via XML. This is basically a method of loading a premade GUI layout.

Example:
\verbatim
<GUISheet name="root">
	<!-- some <Widget> tags in here -->
</GUISheet>
\endverbatim

\par Attributes
 - \c Name
   - \em Type: string
   - \em Default: randomly generated unique string
   - \em Description: The name to give the new GUISheet, or the name of the existing GUISheet you are appending.








<hr>
\section widget <Widget>
This tag allows you to create a widget either explicitly or from a predefined Template, as defined by OpenGUI::System::createWidget(). Widgets created via XML are automatically attached to their parent object via OpenGUI::Element::addChildElement().

Example:
\verbatim
<GUISheet name="root">
	<Widget name="test" group="OpenGUI" type="TextLabel">
		<!-- some <Property> tags in here -->
		<!-- perhaps you'll place recursive <Widget> tags here too -->
		<Widget name="likethis" group="OpenGUI" type="TextLabel">
			<!-- some <Property> tags in here -->
		</Widget>
	</Widget>
</GUISheet>
\endverbatim

\par Attributes
 - \c Name
   - \em Type: string
   - \em Default: randomly generated unique string
   - \em Description: The name to give the new widget.
 - \c Group
   - \em Type: string
   - \em Default: empty string
   - \em Description: The group under which the Widget is registered with the WidgetFactoryManager.
 - \c Type \b (required)
   - \em Type: string
   - \em Description: The type the Widget is registered under with the WidgetFactoryManager, or the name of the Template from which to create this Widget.

\note Widgets that are created from Templates can still provide their own \<Property\> tags, even if those properties would conflict with the settings defined by the Template. The Template properties (if any) are applied first, and then the Widget's explicit properties are applied. So overwriting property values is legal anywhere that a property can be altered after it has been initially set. (Which should be everywhere.) Also, you are not required to provide Properties upon Widget creation.

\warning Even though you can append GUISheets via XML, you cannot delve into a GUISheet's Widget heirarchy via XML. Any appends to a GUISheet must begin at the root level with the creation of a new widget. You can append entire heirarchies of new Widgets to an existing GUISheet, you just cannot insert new Widgets a few levels deep into an existing Widget heirarchy. If you want to do this, you'll need to do it in code. (A cheap method is to build a new GUISheet via XML and then transfer the root level Widgets into the existing heirarchy where you want them via OpenGUI::Element::removeChildElement() and OpenGUI::Element::addChildElement().)







<hr>
\section property <Property>
This tag allows you to set properties for Widgets or Templates, depending on the context they're used in. They translate into calls to either OpenGUI::PropertySet::propertySet() or OpenGUI::WidgetTemplate::addProperty().

Example:
\verbatim
<!-- Stuff above here that makes <Widget> valid -->
	<Widget name="somename" group="somegroup" type="sometype">
		<!-- These are properties defining a Widget -->
		<Property name="BGImagery" value="TachBG" />
		<Property name="NeedleImagery">TachNeedle</Property>
		<Property name="position" value="(0.59875 x0.465)" />
		<Property name="size" value="(0.40125x0.535)" />
		<Property name="needlepivot" value="(0.50x0.50)" />
		<Property name="needleanchor" value="(0.10x0.50)" />
	</Widget>
<!-- Stuff below here that makes <Widget> valid -->

<!-- And in templates! -->
<Template name="tachometer" group="OpenGUIExt" type="Tachometer">
	<!-- These are properties defining a Template -->
	<Property name="BGImagery" value="TachBG" />
	<Property name="NeedleImagery">TachNeedle</Property>
	<Property name="position" value="(0.59875 x0.465)" />
	<Property name="size" value="(0.40125x0.535)" />
	<Property name="needlepivot" value="(0.50x0.50)" />
	<Property name="needleanchor" value="(0.10x0.50)" />
</Template>
\endverbatim

\par Attributes
 - \c Name \b (required)
   - \em Type: string
   - \em Description: The name of the property you are setting.
 - \c Value (required if not given in tag body)
   - \em Type: varies depending on context
   - \em Description: The value you'd like to assign to property referenced by \c Name

Properties are a little trickier to use than the rest of the tags, as the input they take in \c Value can be so varied. The easiest way to explain it is to simply say that \c Value is a string representation of whatever type that the Widget expects for the \c Name'd Property.

\see For a complete list of natively processed string formats, see OpenGUI::PropertySet

\note Make sure you take notice that the \<Property\> tag can accept the \c Value parameter as either an attribute or as the contents of the tag. One or the either must be used. If a \c Value is provided as an attribute, the body text is ignored. Also note that if your \c Value requires the use of \< or \> you will need to use the standard \&lt; and \&gt; representations of these to prevent the xml parser from thinking you've started a new tag. Keep in mind that just because you have line feeds in your XML document does not mean that they will be \em parsed as line feeds. From what I recall, the line feed character is encoding specific, but \&#10; has worked for me in the past (but I never use UTF-8 or any other Unicode style encodings).




<hr>
\section template <Template>
This tag allows you to create Templates that can later be used to create Widgets with preset properties via the OpenGUI::WidgetTemplate class and OpenGUI::WidgetTemplateManager::createTemplate().

Example:
\verbatim
<!-- Stuff above here that makes <Widget> valid -->
	<Widget name="somename" group="somegroup" type="sometype">
		<!-- These are properties defining a 
		<Property name="BGImagery" value="TachBG" />
		<Property name="NeedleImagery" value="TachNeedle" />
		<Property name="position" value="(0.59875 x0.465)" />
		<Property name="size" value="(0.40125x0.535)" />
		<Property name="needlepivot" value="(0.50x0.50)" />
		<Property name="needleanchor" value="(0.10x0.50)" />
	</Widget>
	<Template name="tachometer" group="OpenGUIExt" type="Tachometer">
	</Template>
<!-- Stuff below here that makes <Widget> valid -->
\endverbatim

\par Attributes
 - \c Name \b (required)
   - \em Type: string
   - \em Description: The name to give the template.
 - \c Group \b (required)
   - \em Type: string
   - \em Description: The group under which the base Widget is registered with the WidgetFactoryManager.
 - \c Type \b (required)
   - \em Type: string
   - \em Description: The type the base Widget is registered under with the WidgetFactoryManager.
   
\note Duplicate entries of this tag will append to the previously created Template. Property collisions within the duplicate \<Template\> tags will redefine that property within the Template. Collisions occur based only on \c Name. Once a template is created you cannot alter \c Group or \c Type, as they are ignored in duplicate \<Template\> entries, even though they remain a required attribute.
*/